package util;

import java.util.Random;

public class Neural_Network {
	private Matrix inputs;    				// initial inputs	
	private Matrix input_hidden_weights;	//randomly generated weights for inputs to hidden
	private Matrix hidden_neurons;			// hidden neurons
	private Matrix hidden_neurons_sigmoid;	//hidden neuron whose elements have been put through the sigmoid function
	private Matrix hidden_output_weights;	//randomly generated weights for hidden to output
	private Matrix output;					//output generated by the forward pass
	private Matrix sigmoid_output;			//output whose elements have been put through the sigmoid function
	private Matrix sigmoid_prime_output;	//output whose elements have been put through the f`(sigmoid). used to calculate derivative
	private Matrix sigmoid_prime_hidden;	//hidden neurons whose elements have been put through the f`(sigmoid). used to calculate derivative


	private Matrix targets;					//the inputed targeted value
	Matrix djdw1, djdw2, delta3, delta2;	// represents the gradient decrease. Used to make changes to weights.

	
	
	public Neural_Network(Matrix inputs, Matrix targets ){
		this.inputs = inputs;
		inputs.print(5, 5);
		
		this.targets = targets;

		
		// Generate the necessary random weight matrices
		input_hidden_weights = new Matrix (3,3);
		input_hidden_weights.populate1(input_hidden_weights);
		//populate(input_hidden_weights,3,3);
		input_hidden_weights.print(7, 7);
		hidden_output_weights = new Matrix (3,1);
		hidden_output_weights.populate2(hidden_output_weights);
		hidden_output_weights.print(7, 7);

	}
	
	public Matrix forward_pass(int n){
		
		//calculate the excitation at hidden neuron i
		hidden_neurons = inputs.times(input_hidden_weights);
		//create copy so you don't change the data of hidden_neurons.
		hidden_neurons_sigmoid = hidden_neurons.copy();
		
		double entry;
		//Apply the sigmoid function to each entry of each hidden neuron
		for(int i = 0 ; i<hidden_neurons.getRowDimension() ; i++)
			for(int j = 0 ; j<hidden_neurons.getColumnDimension() ; j++){
				entry = hidden_neurons_sigmoid.get(i, j);
				hidden_neurons_sigmoid.set(i, j, sigmoid(entry));
			}
		
		//calculate the excitation of the output neuron
		output = hidden_neurons.times(hidden_output_weights);
		//apply sigmoid to the output neuron
		entry = 0;
		//You dont want to apply sigmoid to the output itself because you will need it later
		if(n == 1){output.output(output);output.print(2, 2);}
		sigmoid_output = output.copy();
		for(int i = 0 ; i<output.getRowDimension(); i++){
			entry = sigmoid_output.get(i,0);
			entry = sigmoid(entry);
			sigmoid_output.set(i,0, entry);
		}
		//return the output of this forward iteration
		return sigmoid_output;

		
		
	}
	public void printOutput(){
		output.timesEquals(100);
	}
	/*Populate weight matrices*/
	private static  void populate(Matrix m , int rows, int columns){
		double random;
		for( int i = 0 ; i < rows ; i++){
			for( int j = 0 ; j < columns ; j++){
				random = Math.random();
				while(random == 0){
					random = Math.random();
				}
				m.set(i, j, random);
			}
		}
	}
	
	private static double sigmoid(double x){
		double a = 1 /(1+Math.exp(-x));
		return a;
	}
	
	private static double sigmoid_derivative(double x){
		double a = sigmoid(x) * (1-sigmoid(x));
		return a;
	}
	
	
	public void  calculate_cost(){
		delta3 = targets.minus(sigmoid_output);
		delta3.timesEquals(-1);

		
		//Make a copy of output so we can apply sigmoid prime to it without changing anything
		sigmoid_prime_output = output.copy();
		
		double entry;
		//apply the derivative of sigmoid to each element in sigmoid_prime_output
		for(int i = 0 ; i<output.getRowDimension(); i++){
			entry = sigmoid_prime_output.get(i,0);
			entry = sigmoid_derivative(entry);
			sigmoid_prime_output.set(i,0, entry);
		}
		//delta 3 is the back propagating error for the hidden_output weights
		delta3 = delta3.arrayTimes(sigmoid_prime_output);

		Matrix tmp = hidden_neurons_sigmoid.transpose();
		//djdw2 will be subtracted from hidden_output_weights
		djdw2 = tmp.times(delta3);
		djdw2.timesEquals(.10);

		
		tmp = hidden_output_weights.transpose();
		delta2 = delta3.times(tmp);
		//We need to perform sigmoid_prime on the hidden neurons. Make a copy of them and perform it on the copy
		sigmoid_prime_hidden = hidden_neurons.copy();
		//sigmoid_prime_hidden.print(5, 5);
		
		//apply the derivative of sigmoid to each element in sigmoid_prime_hidden
		for(int i = 0 ; i<output.getRowDimension(); i++){
			entry = sigmoid_prime_hidden.get(i,0);
			entry = sigmoid_derivative(entry);
			sigmoid_prime_hidden.set(i,0, entry);
		}
		//sigmoid_prime_hidden.print(5, 5);
		//delta2.print(5, 5);
		delta2 = delta2.arrayTimes(sigmoid_prime_hidden);
		//delta2.print(5, 5);

		tmp = inputs.transpose();
		djdw1 =tmp.times(delta2);
		System.out.println("Guessed output:");
		output.print(5, 5);
		
		if(djdw1.get(0, 0)<0){
			input_hidden_weights.plusEquals(djdw1);
			hidden_output_weights.plusEquals(djdw2);
		}
		else{
		input_hidden_weights.minusEquals(djdw1);
		hidden_output_weights.minusEquals(djdw2);
		}
		

	}
	//Calculate the error rate. This will determine when the network is trained
	public  double errorRate(){
		double error = 0;
		for (int i = 0 ; i< targets.getRowDimension() ; i++){
			error = targets.get(i, 0) - output.get(i, 0);
			error = error * error;
			error += error;
		}
		
		return error/2;
	}
	
	public void changeInput( Matrix m){
		//inputs.print(5, 5);
		inputs = m;
		//inputs.print(5, 5);

	}
	
	
	
	public static void main(String args[]){
		Matrix inputs = new Matrix (5,3);
		//Training input data
		inputs.set(0, 0, .11685);
		inputs.set(0, 1, .11877);
		inputs.set(0, 2, .11662);
		inputs.set(1, 0, .11907);
		inputs.set(1, 1, .11975);
		inputs.set(1, 2, .11745);
		inputs.set(2, 0, .11794);
		inputs.set(2, 1, .11910);
		inputs.set(2, 2, .11783);
		inputs.set(3, 0, .11927);
		inputs.set(3, 1, .11940);
		inputs.set(3, 2, .11805);
		inputs.set(4, 0, .11881);
		inputs.set(4, 1, .11925);
		inputs.set(4, 2, .11127);
		//Trainging target data
		Matrix targets = new Matrix(5,1);
		targets.set(0, 0, .11863);
		targets.set(1,0, .11760);
		targets.set(2,0, .11900);
		targets.set(3,0, .11893);
		targets.set(4,0, .11507);
		
		Matrix prediction_data = new Matrix(5,3);
		inputs.set(0, 0, .11350);
		inputs.set(0, 1, .11575);
		inputs.set(0, 2, .11275);
		inputs.set(1, 0, .11575);
		inputs.set(1, 1, .11635);
		inputs.set(1, 2, .11511);
		inputs.set(2, 0, .11577);
		inputs.set(2, 1, .11720);
		inputs.set(2, 2, .11529);
		inputs.set(3, 0, .11599);
		inputs.set(3, 1, .11608);
		inputs.set(3, 2, .11464);
		inputs.set(4, 0, .11410);
		inputs.set(4, 1, .11465);
		inputs.set(4, 2, .11162);

		Neural_Network test = new Neural_Network(inputs, targets);
		test.forward_pass(0);
		while(test.errorRate() > 1.0016836420069943E-6){
			double error = test.errorRate();
			System.out.println("error rate: "+error);
			test.calculate_cost();
			test.forward_pass(0);
		}
		test.changeInput(prediction_data);
		System.out.println("Prediction:");
		test.forward_pass(1);
		//test.printOutput();
		


	}

}
